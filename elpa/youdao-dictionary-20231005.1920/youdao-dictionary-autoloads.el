;;; youdao-dictionary-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from youdao-dictionary.el

(define-namespace youdao-dictionary- (defconst api-url "http://fanyi.youdao.com/openapi.do?keyfrom=YouDaoCV&key=659600698&type=data&doctype=json&version=1.1&q=%s" "Youdao dictionary API template, URL `http://dict.youdao.com/'.") (defconst api-url-v3 "https://openapi.youdao.com/api" "Youdao dictionary API template, URL `http://dict.youdao.com/'.") (defconst voice-url "http://dict.youdao.com/dictvoice?type=2&audio=%s" "Youdao dictionary API for query the voice of word.") (defcustom secret-key (getenv "YOUDAO_SECRET_KEY") "Youdao dictionary Secret Key. You can get it from ai.youdao.com." :type 'string) (defcustom app-key (getenv "YOUDAO_APP_KEY") "Youdao dictionary App Key. You can get it from ai.youdao.com." :type 'string) (defconst sign-type "v3" "Youdao dictionary sign type") (defcustom from "auto" "Source language. see http://ai.youdao.com/DOCSIRMA/html/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91/API%E6%96%87%E6%A1%A3/%E6%96%87%E6%9C%AC%E7%BF%BB%E8%AF%91%E6%9C%8D%E5%8A%A1/%E6%96%87%E6%9C%AC%E7%BF%BB%E8%AF%91%E6%9C%8D%E5%8A%A1-API%E6%96%87%E6%A1%A3.html" :type 'string) (defcustom to "auto" "dest language. see http://ai.youdao.com/DOCSIRMA/html/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91/API%E6%96%87%E6%A1%A3/%E6%96%87%E6%9C%AC%E7%BF%BB%E8%AF%91%E6%9C%8D%E5%8A%A1/%E6%96%87%E6%9C%AC%E7%BF%BB%E8%AF%91%E6%9C%8D%E5%8A%A1-API%E6%96%87%E6%A1%A3.html" :type 'string) (defcustom buffer-name "*Youdao Dictionary*" "Result Buffer name." :type 'string) (defcustom search-history-file nil "If non-nil, the file be used for saving searching history." :type '(choice (const :tag "Don't save history" nil) (string :tag "File path"))) (defcustom use-chinese-word-segmentation nil "If Non-nil, support Chinese word segmentation(中文分词).

See URL `https://github.com/xuchunyang/chinese-word-at-point.el' for more info." :type 'boolean) (defface posframe-tip-face '((t (:inherit tooltip))) "Face for posframe tip." :group 'youdao-dictionary) (defun secret-key nil (or secret-key (let ((plist (car (auth-source-search :host "openapi.youdao.com" :max 1)))) (and plist (funcall (plist-get plist :secret)))))) (defun app-key nil (or app-key (let ((plist (car (auth-source-search :host "openapi.youdao.com" :max 1)))) (plist-get plist :user)))) (defun get-salt nil (number-to-string (random 1000))) (defun get-curtime nil (format-time-string "%s")) (defun get-input (word) (let ((len (length word))) (if (> len 20) (concat (substring word 0 10) (number-to-string len) (substring word -10)) word))) (defun get-sign (salt curtime word) (let* ((input (get-input word)) (signstr (concat (app-key) input salt curtime (secret-key)))) (secure-hash 'sha256 signstr))) (defun -format-voice-url (query-word) "Format QUERY-WORD as voice url." (format voice-url (url-hexify-string query-word))) (defun -request-v3-p nil (if (and (app-key) (secret-key)) t (user-error "You have not set the API key/secret.  See also URL `https://github.com/xuchunyang/youdao-dictionary.el#usage'."))) (defun -format-request-url (query-word) "Format QUERY-WORD as a HTTP request URL." (if (-request-v3-p) api-url-v3 (format api-url (url-hexify-string query-word)))) (defun -parse-response nil "Parse response as JSON." (set-buffer-multibyte t) (goto-char (point-min)) (when (/= 200 url-http-response-status) (error "Problem connecting to the server")) (re-search-forward "^$" nil 'move) (prog1 (json-read) (kill-buffer (current-buffer)))) (defun -request (word &optional callback) "Request WORD, return JSON as an alist if successes." (when (and search-history-file (file-writable-p search-history-file)) (append-to-file (concat word "
") nil search-history-file)) (let* ((salt (get-salt)) (curtime (get-curtime)) (sign (get-sign salt curtime word)) (url-request-data (when (-request-v3-p) (mapconcat #'identity (list (concat "q=" (url-hexify-string word)) (concat "from=" from) (concat "to=" to) (concat "appKey=" (app-key)) (concat "salt=" salt) (concat "sign=" (url-hexify-string sign)) (concat "signType=" sign-type) (concat "curtime=" curtime)) "&"))) (url-request-method (when (-request-v3-p) "POST")) (url-request-extra-headers (when (-request-v3-p) '(("Content-Type" . "application/x-www-form-urlencoded"))))) (if callback (url-retrieve (-format-request-url word) callback) (with-current-buffer (url-retrieve-synchronously (-format-request-url word)) (-parse-response))))) (defun -explains (json) "Return explains as a vector extracted from JSON." (cdr (assoc 'explains (cdr (assoc 'basic json))))) (defun -prompt-input nil "Prompt input object for translate." (let ((current-word (-region-or-word))) (read-string (format "Word (%s): " (or current-word "")) nil nil current-word))) (defun -strip-explain (explain) "Remove unneed info in EXPLAIN for replace.

i.e. `[语][计] dictionary' => 'dictionary'." (replace-regexp-in-string "^[[].* " "" explain)) (defun -region-or-word nil "Return word in region or word at point." (if (derived-mode-p 'pdf-view-mode) (if (pdf-view-active-region-p) (mapconcat 'identity (pdf-view-active-region-text) "
")) (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (thing-at-point (if use-chinese-word-segmentation 'chinese-or-other-word 'word) t)))) (defun -format-result (json) "Format result in JSON." (let* ((query (assoc-default 'query json)) (translation (assoc-default 'translation json)) (_errorCode (assoc-default 'errorCode json)) (web (assoc-default 'web json)) (basic (assoc-default 'basic json)) (phonetic (assoc-default 'phonetic basic)) (translation-str (mapconcat (lambda (trans) (concat "- " trans)) translation "
")) (basic-explains-str (mapconcat (lambda (explain) (concat "- " explain)) (assoc-default 'explains basic) "
")) (web-str (mapconcat (lambda (k-v) (format "- %s :: %s" (assoc-default 'key k-v) (mapconcat 'identity (assoc-default 'value k-v) "; "))) web "
"))) (if basic (format "%s [%s]

* Basic Explains
%s

* Web References
%s
" query phonetic basic-explains-str web-str) (format "%s

* Translation
%s
" query translation-str)))) (defun -pos-tip (string) "Show STRING using pos-tip-show." (pos-tip-show string nil nil nil 0) (unwind-protect (push (read-event) unread-command-events) (pos-tip-hide))) (defvar current-buffer-word nil) (defun -posframe-tip (string) "Show STRING using posframe-show." (unless (and (require 'posframe nil t) (posframe-workable-p)) (error "Posframe not workable")) (let ((word (-region-or-word))) (if word (progn (with-current-buffer (get-buffer-create buffer-name) (let ((inhibit-read-only t)) (erase-buffer) (mode) (insert string) (goto-char (point-min)) (set (make-local-variable 'youdao-dictionary-current-buffer-word) word))) (posframe-show buffer-name :left-fringe 8 :right-fringe 8 :internal-border-color (face-foreground 'default) :internal-border-width 1) (unwind-protect (push (read-event) unread-command-events) (progn (posframe-delete buffer-name) (other-frame 0)))) (message "Nothing to look up")))) (defun play-voice-of-current-word nil "Play voice of current word shown in *Youdao Dictionary*." (interactive) (if (local-variable-if-set-p 'youdao-dictionary-current-buffer-word) (-play-voice current-buffer-word))) (define-derived-mode mode org-mode "Youdao-dictionary" "Major mode for viewing Youdao dictionary result.
\\{youdao-dictionary-mode-map}" (read-only-mode 1) (define-key mode-map "q" 'quit-window) (define-key mode-map "p" 'youdao-dictionary-play-voice-of-current-word) (define-key mode-map "y" 'youdao-dictionary-play-voice-at-point)) (defun -search-and-show-in-buffer-subr (word content) (with-current-buffer (get-buffer-create buffer-name) (let ((inhibit-read-only t)) (erase-buffer) (mode) (insert content) (goto-char (point-min)) (set (make-local-variable 'youdao-dictionary-current-buffer-word) word)) (unless (get-buffer-window (current-buffer)) (switch-to-buffer-other-window buffer-name)))) (defun -search-and-show-in-buffer (word &optional async) "Search WORD and show result in `youdao-dictionary-buffer-name' buffer." (unless word (user-error "Nothing to look up")) (if async (-request word (lambda (_status) (-search-and-show-in-buffer-subr word (-format-result (-parse-response))))) (-search-and-show-in-buffer-subr word (-format-result (-request word))))) :autoload (defun search-at-point nil "Search word at point and display result with buffer." (interactive) (let ((word (-region-or-word))) (-search-and-show-in-buffer word))) (defun search-at-point- (func) "Search word at point and display result with given FUNC." (let ((word (-region-or-word))) (if word (funcall func (-format-result (-request word))) (message "Nothing to look up")))) :autoload (defun search-at-point+ nil "Search word at point and display result with popup-tip." (interactive) (search-at-point- #'popup-tip)) :autoload (defun search-at-point-posframe nil "Search word at point and display result with posframe." (interactive) (search-at-point- #'-posframe-tip)) :autoload (defun search-at-point-tooltip nil "Search word at point and display result with pos-tip." (interactive) (search-at-point- #'-pos-tip)) :autoload (defun search-from-input nil "Search word from input and display result with buffer." (interactive) (let ((word (-prompt-input))) (-search-and-show-in-buffer word))) :autoload (defun search-and-replace nil "Search word at point and replace this word with popup menu." (interactive) (if (use-region-p) (let ((region-beginning (region-beginning)) (region-end (region-end)) (selected (popup-menu* (mapcar #'-strip-explain (append (-explains (-request (-region-or-word))) nil))))) (when selected (insert selected) (kill-region region-beginning region-end))) (let* ((bounds (bounds-of-thing-at-point (if use-chinese-word-segmentation 'chinese-or-other-word 'word))) (beginning-of-word (car bounds)) (end-of-word (cdr bounds))) (when bounds (let ((selected (popup-menu* (mapcar #'-strip-explain (append (-explains (-request (thing-at-point (if use-chinese-word-segmentation 'chinese-or-other-word 'word)))) nil))))) (when selected (insert selected) (kill-region beginning-of-word end-of-word))))))) (defvar history nil) :autoload (defun search (query) "Show the explanation of QUERY from Youdao dictionary." (interactive (let* ((string (or (if (use-region-p) (buffer-substring (region-beginning) (region-end)) (thing-at-point 'word)) (read-string "Search Youdao Dictionary: " nil 'history)))) (list string))) (-search-and-show-in-buffer query)) :autoload (defun search-async (query) "Show the explanation of QUERY from Youdao dictionary asynchronously." (interactive (let* ((string (or (if (use-region-p) (buffer-substring (region-beginning) (region-end)) (thing-at-point 'word)) (read-string "Search Youdao Dictionary: " nil 'history)))) (list string))) (-search-and-show-in-buffer query 'async)) (defun -play-voice (word) "Play voice of the WORD if there has mplayer or mpg123 program." (let ((player (or (executable-find "mpv") (executable-find "mplayer") (executable-find "mpg123")))) (if player (start-process player nil player (-format-voice-url word)) (user-error "mplayer or mpg123 is needed to play word voice")))) :autoload (defun play-voice-at-point nil "Play voice of the word at point." (interactive) (let ((word (-region-or-word))) (-play-voice word))) :autoload (defun play-voice-from-input nil "Play voice of user input word." (interactive) (let ((word (-prompt-input))) (-play-voice word))))
(register-definition-prefixes "youdao-dictionary" '("-explains" "-format-" "-p" "-re" "-s" "api-url" "app-key" "buffer-name" "current-buffer-word" "from" "get-" "history" "mode" "play-voice-" "sign-type" "use-chinese-word-segmentation" "voice-url"))


;;; End of scraped data

(provide 'youdao-dictionary-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; youdao-dictionary-autoloads.el ends here
